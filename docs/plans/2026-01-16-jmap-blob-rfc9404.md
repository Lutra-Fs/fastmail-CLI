# JMAP Blob Support Implementation Plan (RFC 9404)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement JMAP Blob Management Extension (RFC 9404) for uploading, downloading, and looking up binary data blobs via inline JMAP method calls.

**Architecture:** Extend the three-crates workspace: add Blob types to `jmap-client/src/types.rs`, add Blob methods to `JmapClient`, add capability detection to `FastmailClient`, and add CLI commands for Blob operations.

**Tech Stack:** Rust, serde (JSON), base64 (encoding), thiserror (errors), clap (CLI), tokio (async)

---

## Task 1: Add Dependencies for Base64 and Error Handling

**Files:**
- Modify: `jmap-client/Cargo.toml`
- Modify: `jmap-client/src/lib.rs`

**Step 1: Add base64 and thiserror dependencies to jmap-client/Cargo.toml**

```toml
# jmap-client/Cargo.toml
[package]
name = "jmap-client"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = { workspace = true }
async-trait = "0.1"
base64 = "0.22"
reqwest = { version = "0.12", default-features = false, features = ["json", "rustls-tls"], optional = true }
serde = { workspace = true }
serde_json = { workspace = true }
thiserror = "1.0"
```

**Step 2: Run cargo check to verify dependencies**

Run: `cargo check -p jmap-client`
Expected: OK (dependencies resolve)

**Step 3: Add error module to lib.rs**

```rust
// jmap-client/src/lib.rs
pub mod blob;
pub mod client;
pub mod error;
pub mod http;
pub mod types;

pub use blob::{encode_base64, decode_base64, data_source_from_bytes, data_source_from_text};
pub use client::JmapClient;
pub use error::BlobError;
pub use http::HttpClient;
pub use types::{
    Email, EmailAddress, Mailbox, BodyPart, Session, AccountData,
    // Blob types
    BlobCapability, BlobUploadObject, DataSourceObject,
    BlobCreatedInfo, BlobUploadResponse,
    BlobGetResponse, BlobLookupInfo,
};
```

**Step 4: Commit**

```bash
git add jmap-client/Cargo.toml jmap-client/src/lib.rs
git commit -m "feat(blob): add base64 and thiserror dependencies"
```

---

## Task 2: Create Blob Error Types

**Files:**
- Create: `jmap-client/src/error.rs`

**Step 1: Write the error module**

```rust
// jmap-client/src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum BlobError {
    #[error("Blob capability not supported by server")]
    CapabilityNotSupported,

    #[error("Unknown data type: {0}")]
    UnknownDataType(String),

    #[error("Blob size exceeds maximum: {size} > {max_size}")]
    SizeExceeded { size: u64, max_size: u64 },

    #[error("Invalid data source range: offset={offset}, length={length}")]
    InvalidRange { offset: u64, length: u64 },

    #[error("Blob not found: {0}")]
    NotFound(String),

    #[error("Encoding problem: blob data is not valid UTF-8")]
    EncodingProblem,

    #[error("Blob data was truncated: requested range extends beyond blob")]
    Truncated,

    #[error("Invalid base64 encoding: {0}")]
    InvalidBase64(String),
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (module compiles)

**Step 3: Commit**

```bash
git add jmap-client/src/error.rs
git commit -m "feat(blob): add BlobError enum"
```

---

## Task 3: Create Blob Utilities Module

**Files:**
- Create: `jmap-client/src/blob.rs`

**Step 1: Write the blob utilities module**

```rust
// jmap-client/src/blob.rs
use crate::error::BlobError;
use crate::types::DataSourceObject;
use anyhow::Result;

/// Encode bytes as base64
pub fn encode_base64(data: &[u8]) -> String {
    use base64::prelude::*;
    BASE64_STANDARD.encode(data)
}

/// Decode base64 string to bytes
pub fn decode_base64(s: &str) -> Result<Vec<u8>> {
    use base64::prelude::*;
    BASE64_STANDARD
        .decode(s)
        .map_err(|e| BlobError::InvalidBase64(e.to_string()).into())
}

/// Create DataSourceObject from raw bytes
pub fn data_source_from_bytes(bytes: &[u8]) -> DataSourceObject {
    DataSourceObject::AsBase64 {
        data_as_base64: encode_base64(bytes),
    }
}

/// Create DataSourceObject from text
pub fn data_source_from_text(text: &str) -> DataSourceObject {
    DataSourceObject::AsText {
        data_as_text: text.to_string(),
    }
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (module compiles)

**Step 3: Commit**

```bash
git add jmap-client/src/blob.rs
git commit -m "feat(blob): add base64 utility functions"
```

---

## Task 4: Add Blob Type Definitions to types.rs

**Files:**
- Modify: `jmap-client/src/types.rs`

**Step 1: Add Blob types after the existing types**

```rust
// jmap-client/src/types.rs
// ... existing imports ...

/// JMAP Blob capability (urn:ietf:params:jmap:blob)
#[derive(Debug, Clone, Deserialize)]
pub struct BlobCapability {
    #[serde(rename = "maxSizeBlobSet")]
    pub max_size_blob_set: Option<u64>,
    #[serde(rename = "maxDataSources")]
    pub max_data_sources: u64,
    #[serde(rename = "supportedTypeNames")]
    pub supported_type_names: Vec<String>,
    #[serde(rename = "supportedDigestAlgorithms")]
    pub supported_digest_algorithms: Vec<String>,
}

/// Blob/upload request object
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BlobUploadObject {
    pub data: Vec<DataSourceObject>,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option<String>,
}

/// Data source for blob upload - one of text, base64, or blob reference
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DataSourceObject {
    AsText {
        #[serde(rename = "data:asText")]
        data_as_text: String,
    },
    AsBase64 {
        #[serde(rename = "data:asBase64")]
        data_as_base64: String,
    },
    BlobRef {
        #[serde(rename = "blobId")]
        blob_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        offset: Option<u64>,
        #[serde(skip_serializing_if = "Option::is_none")]
        length: Option<u64>,
    },
}

/// Blob/upload response - info about created blob
#[derive(Debug, Clone, Deserialize)]
pub struct BlobCreatedInfo {
    pub id: String,
    #[serde(rename = "type")]
    pub type_: Option<String>,
    pub size: u64,
}

/// Blob/upload response
#[derive(Debug, Clone, Deserialize)]
pub struct BlobUploadResponse {
    #[serde(rename = "accountId")]
    pub account_id: String,
    #[serde(default)]
    pub created: std::collections::HashMap<String, BlobCreatedInfo>,
    #[serde(default)]
    #[serde(rename = "notCreated")]
    pub not_created: std::collections::HashMap<String, serde_json::Value>,
}

/// Blob/get response for a single blob
#[derive(Debug, Clone, Deserialize)]
pub struct BlobGetResponse {
    pub id: String,
    #[serde(rename = "data:asText")]
    #[serde(default)]
    pub data_as_text: Option<String>,
    #[serde(rename = "data:asBase64")]
    #[serde(default)]
    pub data_as_base64: Option<String>,
    /// Dynamic digest properties (digest:sha, digest:sha-256, etc.)
    #[serde(flatten)]
    pub digests: std::collections::HashMap<String, String>,
    #[serde(default)]
    pub size: u64,
    #[serde(rename = "isEncodingProblem")]
    #[serde(default)]
    pub is_encoding_problem: bool,
    #[serde(rename = "isTruncated")]
    #[serde(default)]
    pub is_truncated: bool,
}

impl BlobGetResponse {
    /// Get digest value for algorithm if present
    pub fn digest(&self, algorithm: &str) -> Option<&String> {
        self.digests.get(&format!("digest:{}", algorithm))
    }

    /// Get data as bytes (decodes base64 if needed)
    pub fn as_bytes(&self) -> Result<Vec<u8>> {
        if let Some(text) = &self.data_as_text {
            Ok(text.as_bytes().to_vec())
        } else if let Some(b64) = &self.data_as_base64 {
            crate::blob::decode_base64(b64)
        } else {
            Err(anyhow::anyhow!("No data available"))
        }
    }

    /// Get data as text if UTF-8 valid
    pub fn as_text(&self) -> Result<String> {
        self.data_as_text
            .clone()
            .ok_or_else(|| anyhow::anyhow!("Data not valid UTF-8"))
    }
}

/// Blob/lookup response for a single blob
#[derive(Debug, Clone, Deserialize)]
pub struct BlobLookupInfo {
    pub id: String,
    #[serde(rename = "matchedIds")]
    pub matched_ids: std::collections::HashMap<String, Vec<String>>,
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (types compile)

**Step 3: Commit**

```bash
git add jmap-client/src/types.rs
git commit -m "feat(blob): add Blob type definitions per RFC 9404"
```

---

## Task 5: Add BLOB_CAPABILITY Constant to client.rs

**Files:**
- Modify: `jmap-client/src/client.rs`

**Step 1: Add BLOB_CAPABILITY constant after MAIL_CAPABILITY**

```rust
// jmap-client/src/client.rs
use crate::blob;
use crate::types::{Email, Mailbox, BlobUploadObject, BlobUploadResponse, BlobGetResponse, BlobLookupInfo};
use anyhow::Result;
use serde_json::json;

const CORE_CAPABILITY: &str = "urn:ietf:params:jmap:core";
const MAIL_CAPABILITY: &str = "urn:ietf:params:jmap:mail";
const BLOB_CAPABILITY: &str = "urn:ietf:params:jmap:blob";
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (constant added, unused warning for blob import is OK for now)

**Step 3: Commit**

```bash
git add jmap-client/src/client.rs
git commit -m "feat(blob): add BLOB_CAPABILITY constant"
```

---

## Task 6: Add blob_upload Method to JmapClient

**Files:**
- Modify: `jmap-client/src/client.rs`

**Step 1: Add blob_upload method after mailbox_get_all**

```rust
// jmap-client/src/client.rs
// In impl<C: HttpClient> JmapClient<C> block, after mailbox_get_all method:

/// Upload blobs via Blob/upload
pub async fn blob_upload(
    &self,
    create: std::collections::HashMap<String, BlobUploadObject>,
) -> Result<BlobUploadResponse> {
    let params = json!({
        "accountId": self.account_id,
        "create": create,
    });

    let using = [CORE_CAPABILITY, BLOB_CAPABILITY];
    let args = self.call_method_with_using(&using, "Blob/upload", params).await?;

    serde_json::from_value(args).map_err(Into::into)
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (method compiles)

**Step 3: Commit**

```bash
git add jmap-client/src/client.rs
git commit -m "feat(blob): add blob_upload method"
```

---

## Task 7: Add blob_get Method to JmapClient

**Files:**
- Modify: `jmap-client/src/client.rs`

**Step 1: Add blob_get method after blob_upload**

```rust
// jmap-client/src/client.rs
// After blob_upload method:

/// Get blob data via Blob/get
pub async fn blob_get(
    &self,
    ids: &[String],
    properties: Option<Vec<String>>,
    offset: Option<u64>,
    length: Option<u64>,
) -> Result<Vec<BlobGetResponse>> {
    if ids.is_empty() {
        return Ok(Vec::new());
    }

    let mut params = json!({
        "accountId": self.account_id,
        "ids": ids,
    });

    if let Some(props) = properties {
        params["properties"] = json!(props);
    }
    if let Some(off) = offset {
        params["offset"] = json!(off);
    }
    if let Some(len) = length {
        params["length"] = json!(len);
    }

    let using = [CORE_CAPABILITY, BLOB_CAPABILITY];
    let args = self.call_method_with_using(&using, "Blob/get", params).await?;

    let list = args
        .get("list")
        .and_then(|v| v.as_array())
        .ok_or_else(|| anyhow::anyhow!("Invalid Blob/get response: no list"))?;

    list.iter()
        .map(|v| serde_json::from_value(v.clone()).map_err(Into::into))
        .collect()
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (method compiles)

**Step 3: Commit**

```bash
git add jmap-client/src/client.rs
git commit -m "feat(blob): add blob_get method with range support"
```

---

## Task 8: Add blob_lookup Method to JmapClient

**Files:**
- Modify: `jmap-client/src/client.rs`

**Step 1: Add blob_lookup method after blob_get**

```rust
// jmap-client/src/client.rs
// After blob_get method:

/// Look up blob references via Blob/lookup
pub async fn blob_lookup(
    &self,
    ids: &[String],
    type_names: &[String],
) -> Result<Vec<BlobLookupInfo>> {
    if ids.is_empty() {
        return Ok(Vec::new());
    }

    let params = json!({
        "accountId": self.account_id,
        "ids": ids,
        "typeNames": type_names,
    });

    let using = [CORE_CAPABILITY, BLOB_CAPABILITY];
    let args = self.call_method_with_using(&using, "Blob/lookup", params).await?;

    let list = args
        .get("list")
        .and_then(|v| v.as_array())
        .ok_or_else(|| anyhow::anyhow!("Invalid Blob/lookup response: no list"))?;

    list.iter()
        .map(|v| serde_json::from_value(v.clone()).map_err(Into::into))
        .collect()
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (method compiles)

**Step 3: Commit**

```bash
git add jmap-client/src/client.rs
git commit -m "feat(blob): add blob_lookup method for reverse reference lookup"
```

---

## Task 9: Add Convenience Methods to JmapClient

**Files:**
- Modify: `jmap-client/src/client.rs`

**Step 1: Add convenience methods after blob_lookup**

```rust
// jmap-client/src/client.rs
// After blob_lookup method:

/// Get blob as text (returns error if not valid UTF-8)
pub async fn blob_get_as_text(&self, id: &str) -> Result<String> {
    let results = self.blob_get(&[id.to_string()], None, None, None).await?;
    let result = results
        .into_iter()
        .next()
        .ok_or_else(|| anyhow::anyhow!("Blob not found"))?;

    if result.is_encoding_problem {
        anyhow::bail!("Blob data is not valid UTF-8");
    }

    result.as_text()
}

/// Get blob as base64
pub async fn blob_get_as_base64(&self, id: &str) -> Result<String> {
    let results = self
        .blob_get(
            &[id.to_string()],
            Some(vec!["data:asBase64".to_string(), "size".to_string()]),
            None,
            None,
        )
        .await?;

    let result = results
        .into_iter()
        .next()
        .ok_or_else(|| anyhow::anyhow!("Blob not found"))?;

    result.data_as_base64
        .ok_or_else(|| anyhow::anyhow!("No base64 data in response"))
}

/// Get blob as raw bytes
pub async fn blob_get_bytes(&self, id: &str) -> Result<Vec<u8>> {
    let results = self.blob_get(&[id.to_string()], None, None, None).await?;
    let result = results
        .into_iter()
        .next()
        .ok_or_else(|| anyhow::anyhow!("Blob not found"))?;
    result.as_bytes()
}

/// Upload text as a blob
pub async fn blob_upload_text(&self, text: &str, type_: Option<&str>) -> Result<String> {
    let mut create = std::collections::HashMap::new();
    create.insert(
        "single".to_string(),
        BlobUploadObject {
            data: vec![blob::data_source_from_text(text)],
            type_: type_.map(|s| s.to_string()),
        },
    );

    let response = self.blob_upload(create).await?;
    let created = response
        .created
        .into_iter()
        .next()
        .ok_or_else(|| anyhow::anyhow!("Upload failed"))?;

    Ok(created.1.id)
}

/// Upload raw bytes as a blob
pub async fn blob_upload_bytes(&self, bytes: &[u8], type_: Option<&str>) -> Result<String> {
    let mut create = std::collections::HashMap::new();
    create.insert(
        "single".to_string(),
        BlobUploadObject {
            data: vec![blob::data_source_from_bytes(bytes)],
            type_: type_.map(|s| s.to_string()),
        },
    );

    let response = self.blob_upload(create).await?;
    let created = response
        .created
        .into_iter()
        .next()
        .ok_or_else(|| anyhow::anyhow!("Upload failed"))?;

    Ok(created.1.id)
}
```

**Step 2: Run cargo check**

Run: `cargo check -p jmap-client`
Expected: OK (all methods compile)

**Step 3: Commit**

```bash
git add jmap-client/src/client.rs
git commit -m "feat(blob): add convenience methods (get_as_text, get_as_base64, get_bytes, upload_text, upload_bytes)"
```

---

## Task 10: Add Blob Capability Detection to FastmailClient

**Files:**
- Modify: `fastmail-client/src/client.rs`
- Modify: `fastmail-client/src/lib.rs`

**Step 1: Add Session access and capability methods to FastmailClient**

```rust
// fastmail-client/src/client.rs
// At the top of the file, add Session to imports:
use jmap_client::{Email, HttpClient, JmapClient, ReqwestClient, Session};

// In pub struct FastmailClient block, add session field:
pub struct FastmailClient {
    inner: JmapClient<ReqwestClient>,
    account_email: String,
    session: Session,
}

// In impl FastmailClient::new, update to store session:
impl FastmailClient {
    pub async fn new(token: String) -> Result<Self> {
        let http_client = ReqwestClient::new().with_token(token.clone());

        // Fetch session from Fastmail
        let session = Self::fetch_session(&http_client).await?;

        // Get account email from session first (before moving session)
        let account_email = Self::get_primary_account_email(&session).await?;

        // Parse account ID from session
        let account_id = Self::select_account_id(&session)?;

        let inner = JmapClient::new(http_client, session.api_url, account_id);

        Ok(Self {
            inner,
            account_email,
            session,
        })
    }

    // ... keep existing methods ...

    /// Check if server supports Blob capability
    pub fn has_blob_capability(&self) -> bool {
        self.session
            .accounts
            .get(self.inner.account_id())
            .and_then(|acc| acc.account_capabilities.as_ref())
            .and_then(|caps| caps.get("urn:ietf:params:jmap:blob"))
            .is_some()
    }

    /// Get Blob capability details if available
    pub fn blob_capability(&self) -> Option<jmap_client::BlobCapability> {
        use jmap_client::BlobCapability;
        self.session
            .accounts
            .get(self.inner.account_id())
            .and_then(|acc| acc.account_capabilities.as_ref())
            .and_then(|caps| caps.get("urn:ietf:params:jmap:blob"))
            .and_then(|v| serde_json::from_value(v.clone()).ok())
    }

    /// Get access to inner JmapClient for direct Blob operations
    pub fn jmap_client(&self) -> &JmapClient<ReqwestClient> {
        &self.inner
    }
}
```

**Step 2: Export BlobCapability from fastmail-client lib.rs**

```rust
// fastmail-client/src/lib.rs
pub use jmap_client::{
    // ... existing exports ...
    BlobCapability,
};
```

**Step 3: Run cargo check**

Run: `cargo check -p fastmail-client`
Expected: OK (methods compile)

**Step 4: Commit**

```bash
git add fastmail-client/src/client.rs fastmail-client/src/lib.rs
git commit -m "feat(blob): add capability detection and jmap_client accessor"
```

---

## Task 11: Add Blob Commands to CLI

**Files:**
- Modify: `fastmail-cli/src/main.rs`
- Create: `fastmail-cli/src/commands/blob.rs`
- Modify: `fastmail-cli/src/main.rs` (to add mod commands)

**Step 1: Create the blob command module**

```rust
// fastmail-cli/src/commands/blob.rs
use crate::output::{print_response, ErrorResponse, Meta, Response};
use anyhow::Result;

#[derive(clap::Subcommand, Clone, Debug)]
pub enum BlobCommands {
    /// Check blob capability
    Capability,
    /// Upload a file as a blob
    Upload {
        /// Path to the file to upload
        path: String,
        /// Media type hint
        #[arg(short, long)]
        type_: Option<String>,
    },
    /// Download blob content
    Download {
        /// Blob ID
        blob_id: String,
        /// Output file path
        #[arg(short, long)]
        output: String,
    },
    /// Get blob metadata
    Info {
        /// Blob ID
        blob_id: String,
    },
    /// Look up references to a blob
    Lookup {
        /// Blob ID
        blob_id: String,
        /// Type names to search (comma-separated)
        #[arg(long, value_delimiter = ',')]
        types: Vec<String>,
    },
}

pub async fn handle_blob_command(
    client: &fastmail_client::FastmailClient,
    cmd: BlobCommands,
) -> Result<()> {
    match cmd {
        BlobCommands::Capability => {
            if client.has_blob_capability() {
                let cap = client.blob_capability();
                let resp = Response::ok(serde_json::json!({
                    "supported": true,
                    "capability": cap
                }));
                print_response(&resp)?;
            } else {
                let resp = Response::ok(serde_json::json!({
                    "supported": false,
                    "capability": null
                }));
                print_response(&resp)?;
            }
            Ok(())
        }
        BlobCommands::Upload { path, type_ } => {
            let content = tokio::fs::read(&path).await?;
            let blob_id = client
                .jmap_client()
                .blob_upload_bytes(&content, type_.as_deref())
                .await?;

            let resp = Response::ok(serde_json::json!({
                "blobId": blob_id,
                "size": content.len()
            }));
            print_response(&resp)?;
            Ok(())
        }
        BlobCommands::Download { blob_id, output } => {
            let data = client.jmap_client().blob_get_bytes(&blob_id).await?;
            tokio::fs::write(&output, data).await?;

            let resp = Response::ok(serde_json::json!({
                "blobId": blob_id,
                "savedTo": output
            }));
            print_response(&resp)?;
            Ok(())
        }
        BlobCommands::Info { blob_id } => {
            let results = client
                .jmap_client()
                .blob_get(&[blob_id], Some(vec!["size".to_string()]), None, None)
                .await?;

            if let Some(info) = results.first() {
                let resp = Response::ok(serde_json::json!({
                    "blobId": info.id,
                    "size": info.size,
                    "isEncodingProblem": info.is_encoding_problem,
                    "isTruncated": info.is_truncated
                }));
                print_response(&resp)?;
            } else {
                let resp = Response::<()>::error(ErrorResponse::not_found(
                    format!("Blob not found: {}", blob_id)
                ));
                print_response(&resp)?;
            }
            Ok(())
        }
        BlobCommands::Lookup { blob_id, types } => {
            let results = client
                .jmap_client()
                .blob_lookup(&[blob_id], &types)
                .await?;

            if let Some(info) = results.first() {
                let resp = Response::ok(serde_json::json!({
                    "blobId": info.id,
                    "matchedIds": info.matched_ids
                }));
                print_response(&resp)?;
            } else {
                let resp = Response::<()>::error(ErrorResponse::not_found(
                    format!("Blob not found: {}", blob_id)
                ));
                print_response(&resp)?;
            }
            Ok(())
        }
    }
}
```

**Step 2: Add commands module and Blob variant to main.rs**

```rust
// fastmail-cli/src/main.rs
mod commands;
mod output;

// In Commands enum, add Blob variant after Config:
#[derive(Subcommand)]
enum Commands {
    /// Email operations
    #[command(subcommand)]
    Mail(MailCommands),
    /// Mailbox operations
    #[command(subcommand)]
    Mailbox(MailboxCommands),
    /// Masked email management
    #[command(subcommand)]
    Masked(MaskedCommands),
    /// Configuration
    #[command(subcommand)]
    Config(ConfigCommands),
    /// Blob operations (JMAP RFC 9404)
    #[command(subcommand)]
    Blob(commands::blob::BlobCommands),
}

// In main() match, add Blob handler:
#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    match cli.command {
        Commands::Mail(cmd) => handle_mail(cmd).await,
        Commands::Mailbox(cmd) => handle_mailbox(cmd).await,
        Commands::Masked(cmd) => handle_masked(cmd).await,
        Commands::Config(cmd) => handle_config(cmd).await,
        Commands::Blob(cmd) => handle_blob(cmd).await,
    }
}

// Add handle_blob function after handle_config:
async fn handle_blob(cmd: commands::blob::BlobCommands) -> Result<()> {
    let client = load_client().await?;
    commands::blob::handle_blob_command(&client, cmd).await
}
```

**Step 3: Create commands directory with mod.rs**

```rust
// fastmail-cli/src/commands/mod.rs
pub mod blob;
```

**Step 4: Run cargo check**

Run: `cargo check -p fastmail-cli`
Expected: OK (CLI compiles)

**Step 5: Commit**

```bash
git add fastmail-cli/src/main.rs fastmail-cli/src/commands/
git commit -m "feat(blob): add CLI commands for Blob operations"
```

---

## Task 12: Fix Missing Mailbox Handler in CLI

**Files:**
- Modify: `fastmail-cli/src/main.rs`

**Step 1: Add handle_mailbox function**

```rust
// fastmail-cli/src/main.rs
// Add after handle_mail function:

async fn handle_mailbox(cmd: MailboxCommands) -> Result<()> {
    match cmd {
        MailboxCommands::List { filter } => {
            let client = load_client().await?;
            let mailboxes = client.list_mailboxes().await?;

            let filtered = if let Some(pattern) = filter {
                let lower = pattern.to_lowercase();
                mailboxes
                    .into_iter()
                    .filter(|m| m.name.to_lowercase().contains(&lower))
                    .collect::<Vec<_>>()
            } else {
                mailboxes
            };

            let resp = Response::ok(filtered);
            print_response(&resp)?;
            Ok(())
        }
    }
}
```

**Step 2: Add list_mailboxes method to FastmailClient**

```rust
// fastmail-client/src/client.rs
// In impl FastmailClient block:

pub async fn list_mailboxes(&self) -> Result<Vec<jmap_client::Mailbox>> {
    self.inner.mailbox_get_all().await
}
```

**Step 3: Run cargo check**

Run: `cargo check`
Expected: OK

**Step 4: Commit**

```bash
git add fastmail-cli/src/main.rs fastmail-client/src/client.rs
git commit -m "fix(cli): add handle_mailbox function"
```

---

## Task 13: Integration Test - Manual Verification

**Files:**
- No file modifications

**Step 1: Build the project**

Run: `cargo build --release`
Expected: Binary compiled successfully

**Step 2: Check blob capability**

Run: `./target/release/fastmail blob capability`
Expected: JSON response showing blob capability support

**Step 3: Upload a test file**

Run:
```bash
echo "Hello, Blob!" > /tmp/test.txt
./target/release/fastmail blob upload /tmp/test.txt --type text/plain
```
Expected: JSON response with blobId

**Step 4: Download the blob**

Run: `./target/release/fastmail blob download <BLOB_ID> /tmp/downloaded.txt`
Expected: File saved, content matches

**Step 5: Get blob info**

Run: `./target/release/fastmail blob info <BLOB_ID>`
Expected: JSON response with size and metadata

**Step 6: Lookup blob references**

Run: `./target/release/fastmail blob lookup <BLOB_ID> --types Email --types Mailbox`
Expected: JSON response with matchedIds

**Step 7: Cleanup test files**

Run: `rm /tmp/test.txt /tmp/downloaded.txt`
Expected: Files removed

**Step 8: Commit (with verification notes)**

```bash
git add -A
git commit -m "chore(blob): manual integration tests passed"
```

---

## Task 14: Add Unit Tests for Blob Types

**Files:**
- Modify: `jmap-client/src/types.rs`

**Step 1: Add tests module at end of types.rs**

```rust
// jmap-client/src/types.rs
// At end of file:

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_data_source_text_serialization() {
        let ds = DataSourceObject::AsText {
            data_as_text: "hello".to_string(),
        };
        let json = serde_json::to_value(ds).unwrap();
        assert_eq!(json, json!({"data:asText": "hello"}));
    }

    #[test]
    fn test_data_source_base64_serialization() {
        let ds = DataSourceObject::AsBase64 {
            data_as_base64: "SGVsbG8=".to_string(),
        };
        let json = serde_json::to_value(ds).unwrap();
        assert_eq!(json, json!({"data:asBase64": "SGVsbG8="}));
    }

    #[test]
    fn test_data_source_blob_ref_serialization() {
        let ds = DataSourceObject::BlobRef {
            blob_id: "G123".to_string(),
            offset: Some(10),
            length: Some(100),
        };
        let json = serde_json::to_value(ds).unwrap();
        assert_eq!(
            json,
            json!({"blobId": "G123", "offset": 10, "length": 100})
        );
    }

    #[test]
    fn test_blob_get_response_digest() {
        let json = json!({
            "id": "G123",
            "size": 100,
            "digest:sha": "abc123",
            "digest:sha-256": "def456"
        });
        let resp: BlobGetResponse = serde_json::from_value(json).unwrap();
        assert_eq!(resp.digest("sha"), Some(&"abc123".to_string()));
        assert_eq!(resp.digest("sha-256"), Some(&"def456".to_string()));
        assert_eq!(resp.digest("md5"), None);
    }
}
```

**Step 2: Run tests**

Run: `cargo test -p jmap-client types`
Expected: All tests pass

**Step 3: Commit**

```bash
git add jmap-client/src/types.rs
git commit -m "test(blob): add unit tests for Blob types"
```

---

## Task 15: Add Unit Tests for Blob Utilities

**Files:**
- Modify: `jmap-client/src/blob.rs`

**Step 1: Add tests module at end of blob.rs**

```rust
// jmap-client/src/blob.rs
// At end of file:

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_base64() {
        assert_eq!(encode_base64(b"hello"), "aGVsbG8=");
        assert_eq!(encode_base64(b""), "");
    }

    #[test]
    fn test_decode_base64() {
        assert_eq!(decode_base64("aGVsbG8=").unwrap().as_slice(), b"hello");
        assert_eq!(decode_base64("").unwrap().as_slice(), b"");
    }

    #[test]
    fn test_decode_base64_invalid() {
        assert!(decode_base64("not-valid-base64!!!").is_err());
    }

    #[test]
    fn test_data_source_from_bytes() {
        let ds = data_source_from_bytes(b"hello");
        match ds {
            DataSourceObject::AsBase64 { data_as_base64 } => {
                assert_eq!(data_as_base64, "aGVsbG8=");
            }
            _ => panic!("Expected AsBase64 variant"),
        }
    }

    #[test]
    fn test_data_source_from_text() {
        let ds = data_source_from_text("hello world");
        match ds {
            DataSourceObject::AsText { data_as_text } => {
                assert_eq!(data_as_text, "hello world");
            }
            _ => panic!("Expected AsText variant"),
        }
    }
}
```

**Step 2: Run tests**

Run: `cargo test -p jmap-client blob`
Expected: All tests pass

**Step 3: Commit**

```bash
git add jmap-client/src/blob.rs
git commit -m "test(blob): add unit tests for blob utilities"
```

---

## Task 16: Update README with Blob Usage Examples

**Files:**
- Modify: `README.md` (or create if doesn't exist)

**Step 1: Add Blob section to README**

```markdown
# Fastmail CLI

## Blob Operations (JMAP RFC 9404)

Check if your account supports Blob operations:

\`\`\`sh
fastmail blob capability
\`\`\`

Upload a file as a blob:

\`\`\`sh
fastmail blob upload document.pdf --type application/pdf
# Returns: {"blobId": "Gabc123...", "size": 12345}
\`\`\`

Download blob content:

\`\`\`sh
fastmail blob download Gabc123... output.pdf
\`\`\`

Get blob metadata:

\`\`\`sh
fastmail blob info Gabc123...
# Returns: {"blobId": "...", "size": 12345, ...}
\`\`\`

Look up which objects reference a blob:

\`\`\`sh
fastmail blob lookup Gabc123... --types Email --types Mailbox
# Returns which emails/mailboxes contain this blob
\`\`\`
```

**Step 2: Run cargo check**

Run: `cargo check`
Expected: OK (README doesn't affect compilation)

**Step 3: Commit**

```bash
git add README.md
git commit -m "docs(blob): add usage examples for Blob operations"
```

---

## Task 17: Final Integration Build and Smoke Test

**Files:**
- No file modifications

**Step 1: Full clean build**

Run:
```bash
cargo clean
cargo build --release
```
Expected: Clean build succeeds, no warnings

**Step 2: Run all tests**

Run: `cargo test --workspace`
Expected: All tests pass

**Step 3: Smoke test all CLI commands**

Run:
```bash
./target/release/fastmail --help
./target/release/fastmail blob --help
./target/release/fastmail blob capability
```
Expected: Help displays, capability command works

**Step 4: Git tag for completion**

Run:
```bash
git tag -a v0.2.0 -m "Add JMAP Blob support (RFC 9404)"
git push origin v0.2.0
```

**Step 5: Final commit**

```bash
git add -A
git commit -m "release(blob): v0.2.0 - JMAP Blob support complete"
```

---

## Implementation Notes

**RFC 9404 Reference:** `ref-docs/jmap-blob-rfc9404.txt`

**Key Implementation Decisions:**

1. **DataSourceObject enum**: Uses `#[serde(untagged)]` to handle the three variants (text, base64, blob reference) cleanly

2. **BlobGetResponse digests**: Uses `#[serde(flatten)]` to capture dynamic `digest:<algorithm>` properties

3. **Base64 dependency**: Version 0.22 for the modern `BASE64_STANDARD` API

4. **Error handling**: `BlobError` enum with `thiserror` for compile-time error Display implementation

5. **Capability detection**: Stored in `FastmailClient.session` for access without re-fetching

6. **CLI design**: Follows existing pattern with subcommands and JSON output envelope

**Testing Strategy:**

1. **Unit tests**: For serialization/deserialization and utility functions
2. **Manual integration tests**: For end-to-end CLI verification
3. **No mock tests**: Real server calls require Fastmail account with Blob support

**Future Enhancements:**

1. Chunked upload for large files
2. Progress bars for large downloads
3. Blob export to different formats
4. Batch operations for multiple blobs
